{
	"Boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"/**",
			" *    Author:  Rohit Meena",
			" *    Created: $CURRENT_DATE.$CURRENT_MONTH.$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
			"**/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"#define sortall(x) sort(all(x))",
			"#define sz(x) (int)(x.size())",
			"#define nl '\\n'",
			"",
			"#ifdef JAI_SHREE_KRISHNA",
			"  #include <debug.h>",
			"#else",
			"  #define dbg(x...) 32",
			"#endif",
			"",
			"typedef long long ll;",
			"typedef unsigned long long ull;",
			"typedef long double ld;",
			"typedef pair<int, int> pii;",
			"typedef pair<ll, ll> pll;",
			"typedef vector<int> vi;",
			"typedef vector<ll> vl;",
			"typedef vector<vi> vvi;",
			"typedef vector<vl> vvl;",
			"typedef vector<pii> vii;",
			"typedef vector<pll> vll;",
			"",
			"// Operator overloads",
			"template<typename T1, typename T2> istream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.first >> p.second); }",
			"template<typename T> istream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}",
			"template<typename T1, typename T2> ostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.first << \" \" << p.second); }",
			"template<typename T> ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }",
			"",
			"const ll mod = 1000000007;",
			"const ld eps = 1e-9;",
			"const ll inf = 1e18;",
			"const int MAXN = 1e6 + 1;",
			"",
			"/**************************** --- Add Global Variables & Functions --- ****************************/",
			"string yes = \"YES\\n\",no = \"NO\\n\";",
			"/**************************** ---------------------------------------- ****************************/",
			"",
			"void precompute(){",
			"  ",
			"}",
			"void solve(){",
			"  ${0}",
			"}",
			"",
			"int main() {",
			"  ios_base::sync_with_stdio(false);",
			"  cin.tie(NULL);",
			"  #ifdef JAI_SHREE_KRISHNA",
			"    freopen(\"input.txt\",\"r\",stdin);",
			"    freopen(\"output.txt\",\"w\",stdout);",
			"    freopen(\"error.txt\",\"w\",stderr);",
			"  #endif",
			"  int tc=1;",
			"  ${1}cin>>tc;",
			"  precompute();",
			"  for(int i = 1; i <= tc; i++){",
			"    // cout<<\"Case #\"<<i<<\": \";",
			"    solve();",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "Boilerplate"
	},
	"Pragma": {
		"prefix": "pragma",
		"body": [
			"#pragma GCC optimize(\"O3,unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
		],
		"description": "Pragma"
	},
	"Simple": {
		"prefix": "simple",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#ifdef JAI_SHREE_KRISHNA",
			"#include <debug.h>",
			"#else",
			"#define dbg(x...) 32",
			"#endif",
			"",
			"#define ll long long",
			"",
			"void solve(){",
			"  ${0}",
			"}",
			"",
			"int main() {",
			"  ios_base::sync_with_stdio(false);",
			"  cin.tie(NULL);",
			"  int tc=1;",
			"  ${1}cin>>tc;",
			"  for(int i = 1; i <= tc; i++){",
			"    // cout<<\"Case #\"<<i<<\": \";",
			"    solve();",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "Simple"
	},
	"Forward For Loop": {
		"prefix": "for",
		"body": [
			"for(int ${1:i} = ${2:0};${1:i} < ${3:n};${1:i}++){",
			"  ${0}",
			"}"
		],
		"description": "Forward For Loop"
	},
	"Reverse For Loop": {
		"prefix": "rfor",
		"body": [
			"for(int ${1:i} = ${2:n-1};${1:i} >= ${3:0};${1:i}--){",
			"  ${0}",
			"}"
		],
		"description": "Reverse For Loop"
	},
	"Range based For Loop": {
		"prefix": "forrange",
		"body": ["for(auto &${1:i} : ${2:v}){", "  ${0}", "}"],
		"description": "Range based For Loop"
	},
	"Binary Exponentiation": {
		"prefix": "binpow",
		"body": [
			"long long binpow(long long a, long long b, long long p = mod){",
			"  long long res = 1;",
			"  while (b > 0){",
			"    if(b & 1) res = (res * a) % p;",
			"    a = (a * a) % p;",
			"    b >>= 1;",
			"  }",
			"  return res;",
			"}"
		],
		"description": "Binary Exponentiation"
	},
	"Seive of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"for (int i = 2; i < MAXN; i++){",
			"  if(lp[i] == 0){",
			"    lp[i] = i;",
			"    for (int j = 2*i; j < MAXN; j+=i){",
			"      if(lp[j] == 0) lp[j] = i;",
			"    }",
			"  }",
			"}",
			"vi lp(MAXN);"
		],
		"description": "Seive of Eratosthenes"
	},
	"Disjoint Set Union": {
		"prefix": "dsu",
		"body": [
			"struct DSU{",
			"  int c;",
			"  vector<int> par, size;",
			"  DSU(int _n){",
			"    c = _n;",
			"    par.resize(_n + 1);",
			"    size.assign(_n + 1, 1);",
			"    iota(par.begin(), par.end(), 0);",
			"  }",
			"  int leader(int u){",
			"    return u == par[u] ? u : par[u] = leader(par[u]);",
			"  }",
			"  bool same(int u,int v){",
			"    return leader(u) == leader(v);",
			"  }",
			"  int get_size(int u){",
			"    return size[leader(u)];",
			"  }",
			"  int count(){",
			"    return c;",
			"  }",
			"  bool merge(int u,int v){",
			"    if((u = leader(u)) == (v = leader(v))) return false;",
			"    c--;",
			"    if(size[u] < size[v]) swap(u,v);",
			"    par[v] = u;",
			"    size[u] += size[v];",
			"    return true;",
			"  }",
			"};"
		],
		"description": "Disjoint Set Union"
	},
	"Policy Based Data Structures": {
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"template <typename K, typename V, typename Comp = std::less<K>> using ordered_map = __gnu_pbds::tree<K, V, Comp, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
			"template <typename K, typename Comp = std::less<K>> using ordered_set = ordered_map<K, __gnu_pbds::null_type, Comp>;",
			"// s.find_by_order(k)     ->  kth element",
			"// s.order_of_key(k)      ->  number of elements less than k (first elements in case of map)"
		],
		"description": "Policy Based Data Structures"
	},
	"Hashmaps with splitmix64 Hash": {
		"prefix": "hashmap",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"struct splitmix64_hash {",
			"  static uint64_t splitmix64(uint64_t x) {",
			"    // http://xorshift.di.unimi.it/splitmix64.c",
			"    x += 0x9e3779b97f4a7c15;",
			"    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"    return x ^ (x >> 31);",
			"  }",
			"",
			"  size_t operator()(uint64_t x) const {",
			"    static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
			"    return splitmix64(x + FIXED_RANDOM);",
			"  }",
			"};",
			"",
			"template <typename K, typename V, typename Hash = splitmix64_hash>",
			"using HashMap = __gnu_pbds::gp_hash_table<K, V, Hash>;",
			"",
			"template <typename K, typename Hash = splitmix64_hash>",
			"using HashSet = HashMap<K, __gnu_pbds::null_type, Hash>;"
		],
		"description": "Hashmaps with splitmix64 Hash"
	},
	"Node and update class for segtree": {
		"prefix": "infotag",
		"body": [
			"struct Tag {",
			"  int add = 0;",
			"  ",
			"  void apply(const Tag &t) & {",
			"    add += t.add;",
			"  }",
			"};",
			"struct Info {",
			"  int mn = 1e9;",
			"  void apply(const Tag &t) & {",
			"    mn += t.add;",
			"  }",
			"};",
			" ",
			"Info operator+(Info &l, Info &r) {",
			"  return min(l.mn, r.mn);",
			"}"
		],
		"description": "Node and update class for segtree"
	},
	"Random Number Generator": {
		"prefix": "random",
		"body": [
			"mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
			"long long rand(long long a, long long b) { return uniform_int_distribution<long long>(a, b)(rng); }"
		],
		"description": "Random Number Generator"
	},
	"Modular Integer": {
		"prefix": "mint",
		"body": [
			"template <const int MOD>",
			"struct modint {",
			"  int value;",
			"  modint() = default;",
			"  modint(int value_) : value(value_) {}",
			"  inline modint<MOD> operator + (modint<MOD> other) const { int c = this->value + other.value; return modint<MOD>(c >= MOD ? c - MOD : c); }",
			"  inline modint<MOD> operator - (modint<MOD> other) const { int c = this->value - other.value; return modint<MOD>(c <    0 ? c + MOD : c); }",
			"  inline modint<MOD> operator * (modint<MOD> other) const { int c = (ll)this->value * other.value % MOD; return modint<MOD>(c < 0 ? c + MOD : c); }",
			"  inline modint<MOD> & operator += (modint<MOD> other) { this->value += other.value; if (this->value >= MOD) this->value -= MOD; return *this; }",
			"  inline modint<MOD> & operator -= (modint<MOD> other) { this->value -= other.value; if (this->value <    0) this->value += MOD; return *this; }",
			"  inline modint<MOD> & operator *= (modint<MOD> other) { this->value = (ll)this->value * other.value % MOD; if (this->value < 0) this->value += MOD; return *this; }",
			"  inline modint<MOD> operator - () const { return modint<MOD>(this->value ? MOD - this->value : 0); }",
			"  modint<MOD> pow(ull k) const { modint<MOD> x = *this, y = 1; for (; k; k >>= 1) { if (k & 1) y *= x; x *= x; } return y; }",
			"  modint<MOD> inv() const { return pow(MOD - 2); }  // MOD must be a prime",
			"  inline modint<MOD> operator /  (modint<MOD> other) const { return *this *  other.inv(); }",
			"  inline modint<MOD> operator /= (modint<MOD> other)       { return *this *= other.inv(); }",
			"  inline bool operator == (modint<MOD> other) const { return value == other.value; }",
			"  inline bool operator != (modint<MOD> other) const { return value != other.value; }",
			"  inline bool operator < (modint<MOD> other) const { return value < other.value; }",
			"  inline bool operator > (modint<MOD> other) const { return value > other.value; }",
			"};",
			"template <int MOD> modint<MOD> operator * (ll value, modint<MOD> n) { return modint<MOD>(value) * n; }",
			"template <int MOD> modint<MOD> operator * (int value, modint<MOD> n) { return modint<MOD>(value % MOD) * n; }",
			"template <int MOD> istream & operator >> (istream & in, modint<MOD> &n) { return in >> n.value; }",
			"template <int MOD> ostream & operator << (ostream & out, modint<MOD> n) { return out << n.value; }",
			"",
			"using mint = modint<mod>;"
		],
		"description": "Modular Integer"
	},
	"Combinatorics": {
		"prefix": "combi",
		"body": [
			"struct combi{",
			"  int max_N; vector<mint> facts, finvs, invs;",
			"  combi(int _n): max_N(_n), facts(_n), finvs(_n), invs(_n){",
			"    facts[0] = finvs[0] = 1;",
			"    invs[1] = 1;",
			"    for (int i = 2; i < max_N; i++) invs[i] =  invs[mod % i] * (-mod / i);",
			"    for(int i = 1; i < max_N; i++){",
			"      facts[i] = facts[i - 1] * i;",
			"      finvs[i] = finvs[i - 1] * invs[i];",
			"    }",
			"  }",
			"  inline mint fact(int n) { return facts[n]; }",
			"  inline mint finv(int n) { return finvs[n]; }",
			"  inline mint inv(int n) { return invs[n]; }",
			"  inline mint ncr(int n, int k) { return n < k or k < 0 ? 0 : facts[n] * finvs[k] * finvs[n-k]; }",
			"};",
			"combi C(MAXN);"
		],
		"description": "Combinatorics"
	},
	"Segment Tree": {
		"prefix": "segtree",
		"body": [
			"template<class Info>",
			"struct SegmentTree {",
			"  int n;",
			"  std::vector<Info> info;",
			"  SegmentTree() : n(0) {}",
			"  SegmentTree(int n_, Info v_ = Info()) {",
			"    init(n_, v_);",
			"  }",
			"  template<class T>",
			"  SegmentTree(std::vector<T> init_) {",
			"    init(init_);",
			"  }",
			"  void init(int n_, Info v_ = Info()) {",
			"    init(std::vector(n_, v_));",
			"  }",
			"  template<class T>",
			"  void init(std::vector<T> init_) {",
			"    n = init_.size();",
			"    info.assign(4 << std::__lg(n), Info());",
			"    std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"        if (r - l == 1) {",
			"            info[p] = init_[l];",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        build(2 * p, l, m);",
			"        build(2 * p + 1, m, r);",
			"        pull(p);",
			"    };",
			"    build(1, 0, n);",
			"  }",
			"  void pull(int p) {",
			"    info[p] = info[2 * p] + info[2 * p + 1];",
			"  }",
			"  void modify(int p, int l, int r, int x, const Info &v) {",
			"    if (r - l == 1) {",
			"      info[p] = v;",
			"      return;",
			"    }",
			"    int m = (l + r) / 2;",
			"    if (x < m) modify(2 * p, l, m, x, v);",
			"    else modify(2 * p + 1, m, r, x, v);",
			"    pull(p);",
			"  }",
			"  void modify(int p, const Info &v) {",
			"    modify(1, 0, n, p, v);",
			"  }",
			"  Info rangeQuery(int p, int l, int r, int x, int y) {",
			"    if (l >= y || r <= x) return Info();",
			"    if (l >= x && r <= y) return info[p];",
			"    int m = (l + r) / 2;",
			"    return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
			"  }",
			"  Info rangeQuery(int l, int r) {",
			"    return rangeQuery(1, 0, n, l, r);",
			"  }",
			"  template<class F>",
			"  int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"    if (l >= y || r <= x || !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"    ",
			"    int m = (l + r) / 2;",
			"    int res = findFirst(2 * p, l, m, x, y, pred);",
			"    if (res == -1) {",
			"      res = findFirst(2 * p + 1, m, r, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findFirst(int l, int r, F pred) {",
			"    return findFirst(1, 0, n, l, r, pred);",
			"  }",
			"  template<class F>",
			"  int findLast(int p, int l, int r, int x, int y, F pred) {",
			"    if (l >= y || r <= x || !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"",
			"    int m = (l + r) / 2;",
			"    int res = findLast(2 * p + 1, m, r, x, y, pred);",
			"    if (res == -1) {",
			"      res = findLast(2 * p, l, m, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findLast(int l, int r, F pred) {",
			"    return findLast(1, 0, n, l, r, pred);",
			"  }",
			"};"
		],
		"description": "Segment Tree"
	},
	"Lazy Segment Tree": {
		"prefix": "lsegtree",
		"body": [
			"template<class Info, class Tag>",
			"struct LazySegmentTree {",
			"  int n;",
			"  std::vector<Info> info;",
			"  std::vector<Tag> tag;",
			"  LazySegmentTree() : n(0) {}",
			"  LazySegmentTree(int n_, Info v_ = Info()) {",
			"    init(n_, v_);",
			"  }",
			"  template<class T>",
			"  LazySegmentTree(std::vector<T> init_) {",
			"    init(init_);",
			"  }",
			"  void init(int n_, Info v_ = Info()) {",
			"    init(std::vector(n_, v_));",
			"  }",
			"  template<class T>",
			"  void init(std::vector<T> init_) {",
			"    n = init_.size();",
			"    info.assign(4 << std::__lg(n), Info());",
			"    tag.assign(4 << std::__lg(n), Tag());",
			"    std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"      if (r - l == 1) {",
			"        info[p] = init_[l];",
			"        return;",
			"      }",
			"      int m = (l + r) / 2;",
			"      build(2 * p, l, m);",
			"      build(2 * p + 1, m, r);",
			"      pull(p);",
			"    };",
			"    build(1, 0, n);",
			"  }",
			"  void pull(int p) {",
			"    info[p] = info[2 * p] + info[2 * p + 1];",
			"  }",
			"  void apply(int p, const Tag &v) {",
			"    info[p].apply(v);",
			"    tag[p].apply(v);",
			"  }",
			"  void push(int p) {",
			"    apply(2 * p, tag[p]);",
			"    apply(2 * p + 1, tag[p]);",
			"    tag[p] = Tag();",
			"  }",
			"  void modify(int p, int l, int r, int x, const Info &v) {",
			"    if (r - l == 1) {",
			"      info[p] = v;",
			"      return;",
			"    }",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    if (x < m) modify(2 * p, l, m, x, v);",
			"    else modify(2 * p + 1, m, r, x, v);",
			"    pull(p);",
			"  }",
			"  void modify(int p, const Info &v) {",
			"    modify(1, 0, n, p, v);",
			"  }",
			"  Info rangeQuery(int p, int l, int r, int x, int y) {",
			"    if (l >= y || r <= x) return Info();",
			"    if (l >= x && r <= y) return info[p];",
			"    ",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
			"  }",
			"  Info rangeQuery(int l, int r) {",
			"    return rangeQuery(1, 0, n, l, r);",
			"  }",
			"  void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
			"    if (l >= y || r <= x) return;",
			"    if (l >= x && r <= y) {",
			"      apply(p, v);",
			"      return;",
			"    }",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    rangeApply(2 * p, l, m, x, y, v);",
			"    rangeApply(2 * p + 1, m, r, x, y, v);",
			"    pull(p);",
			"  }",
			"  void rangeApply(int l, int r, const Tag &v) {",
			"    return rangeApply(1, 0, n, l, r, v);",
			"  }",
			"  template<class F>",
			"  int findFirst(int p, int l, int r, int x, int y, F &&pred) {",
			"    if (l >= y || r <= x) return -1;",
			"    if (l >= x && r <= y && !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"    ",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    int res = findFirst(2 * p, l, m, x, y, pred);",
			"    if (res == -1) {",
			"      res = findFirst(2 * p + 1, m, r, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findFirst(int l, int r, F &&pred) {",
			"    return findFirst(1, 0, n, l, r, pred);",
			"  }",
			"  template<class F>",
			"  int findLast(int p, int l, int r, int x, int y, F &&pred) {",
			"    if (l >= y || r <= x) return -1;",
			"    if (l >= x && r <= y && !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"    ",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    int res = findLast(2 * p + 1, m, r, x, y, pred);",
			"    if (res == -1) {",
			"      res = findLast(2 * p, l, m, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findLast(int l, int r, F &&pred) {",
			"    return findLast(1, 0, n, l, r, pred);",
			"  }",
			"};"
		],
		"description": "Lazy Segment Tree"
	},
	"Matrix Structure": {
		"prefix": "matrix",
		"body": [
			"struct Mat {",
			"  int n, m;",
			"  vector<vector<int>> a;",
			"  Mat() { }",
			"  Mat(int _n, int _m) {n = _n; m = _m; a.assign(n, vector<int>(m, 0)); }",
			"  Mat(vector< vector<int> > v) { n = v.size(); m = n ? v[0].size() : 0; a = v; }",
			"  inline void make_unit() {",
			"    assert(n == m);",
			"    for (int i = 0; i < n; i++)  {",
			"      for (int j = 0; j < n; j++) a[i][j] = i == j;",
			"    }",
			"  }",
			"  inline Mat operator + (const Mat &b) {",
			"    assert(n == b.n && m == b.m);",
			"    Mat ans = Mat(n, m);",
			"    for(int i = 0; i < n; i++) {",
			"      for(int j = 0; j < m; j++) {",
			"        ans.a[i][j] = (a[i][j] + b.a[i][j]) % mod;",
			"      }",
			"    }",
			"    return ans;",
			"  } ",
			"  inline Mat operator - (const Mat &b) {",
			"    assert(n == b.n && m == b.m);",
			"    Mat ans = Mat(n, m);",
			"    for(int i = 0; i < n; i++) {",
			"      for(int j = 0; j < m; j++) {",
			"        ans.a[i][j] = (a[i][j] - b.a[i][j] + mod) % mod;",
			"      }",
			"    }",
			"    return ans;",
			"  }",
			"  inline Mat operator * (const Mat &b) {",
			"    assert(m == b.n);",
			"    Mat ans = Mat(n, b.m);",
			"    for(int i = 0; i < n; i++) {",
			"      for(int j = 0; j < b.m; j++) {",
			"        for(int k = 0; k < m; k++) {",
			"          ans.a[i][j] = (ans.a[i][j] + 1LL * a[i][k] * b.a[k][j] % mod) % mod;",
			"        }",
			"      }",
			"    }",
			"    return ans;",
			"  }",
			"  inline Mat pow(long long k) {",
			"    assert(n == m);",
			"    Mat ans(n, n), t = a; ans.make_unit();",
			"    while (k) {",
			"      if (k & 1) ans = ans * t;",
			"      t = t * t;",
			"      k >>= 1;",
			"    }",
			"    return ans;",
			"  }",
			"  inline Mat& operator += (const Mat& b) { return *this = (*this) + b; }",
			"  inline Mat& operator -= (const Mat& b) { return *this = (*this) - b; }",
			"  inline Mat& operator *= (const Mat& b) { return *this = (*this) * b; }",
			"  inline bool operator == (const Mat& b) { return a == b.a; }",
			"  inline bool operator != (const Mat& b) { return a != b.a; }",
			"};"
		],
		"description": "Matrix Structure"
	},
	"Prefix trie": {
		"prefix": "trie",
		"body": [
			"struct Trie{",
			"    static const int ALPHA = 26;    //Number of alphabets;",
			"    static const char c = 'a';      //Starting alphabet;",
			"    struct node{",
			"        node* child[ALPHA];",
			"        int start,stop;",
			"        node(){",
			"            for(int i = 0;i<ALPHA;i++) child[i] = NULL;",
			"            start = stop = 0;",
			"        }",
			"    }*root;",
			"    ",
			"    Trie(){",
			"        root = new node();",
			"    }",
			"    void insert(string s){          //insert string into trie",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            if(!cur->child[s[i]-c]) cur->child[s[i]-c] = new node();",
			"            cur->start++;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        cur->start++;",
			"        cur->stop++;",
			"    }",
			"    bool search(string s){          //search if a string is present or not",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            if(!cur->child[s[i]-c]) return false;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        return cur->stop;",
			"    }",
			"    int count(string s){            //count how many words have prefix=s",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            if(!cur->child[s[i]-c]) return 0;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        return cur->start;",
			"    }",
			"    void dfs(node* cur){            //perform preorder dfs on trie",
			"        for(int i = 0;i<ALPHA;i++){",
			"            if(cur->child[i]){",
			"                cout<<char(c+i);",
			"                if(cur->child[i]->stop) cout<<\"# \";",
			"                else cout<<\" \";",
			"                dfs(cur->child[i]);",
			"            }",
			"        }",
			"    }",
			"    void del(string s){           //delete a word from trie",
			"        if(!search(s)) return;",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            cur->start--;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        cur->start--;",
			"        cur->stop--;",
			"    }",
			"};"
		],
		"description": "Prefix trie"
	},
	"Binary Trie": {
		"prefix": "bintrie",
		"body": [
			"struct BinTrie{",
			"    static const int B = 31;",
			"    struct node{",
			"        node *nxt[2];",
			"        int sz;",
			"        node(){",
			"            nxt[0] = nxt[1] = NULL;",
			"            sz = 0;",
			"        }",
			"    } *root;",
			"    BinTrie(){",
			"        root = new node();",
			"    }",
			"    void insert(int val){",
			"        node *cur = root;",
			"        cur->sz++;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int b = val >> i & 1;",
			"            if (cur->nxt[b] == NULL)",
			"                cur->nxt[b] = new node();",
			"            cur = cur->nxt[b];",
			"            cur->sz++;",
			"        }",
			"    }",
			"    bool search(int val){",
			"        node *cur = root;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int b = val >> i & 1;",
			"            if (cur->nxt[b] == NULL) return false;",
			"            cur = cur->nxt[b];",
			"        }",
			"        return true;",
			"    }",
			"    int query(int x, int k){ // number of values s.t. val ^ x < k",
			"        node *cur = root;",
			"        int ans = 0;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            if (cur == NULL) break;",
			"            int b1 = x >> i & 1, b2 = k >> i & 1;",
			"            if (b2 == 1){",
			"                if (cur->nxt[b1])",
			"                    ans += cur->nxt[b1]->sz;",
			"                cur = cur->nxt[!b1];",
			"            }",
			"            else cur = cur->nxt[b1];",
			"        }",
			"        return ans;",
			"    }",
			"    int get_max(int x){ // returns maximum of val ^ x",
			"        node *cur = root;",
			"        int ans = 0;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int k = x >> i & 1;",
			"            if (cur->nxt[!k]) cur = cur->nxt[!k], ans <<= 1, ans++;",
			"            else cur = cur->nxt[k], ans <<= 1;",
			"        }",
			"        return ans;",
			"    }",
			"    int get_min(int x){ // returns minimum of val ^ x",
			"        node *cur = root;",
			"        int ans = 0;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int k = x >> i & 1;",
			"            if (cur->nxt[k]) cur = cur->nxt[k], ans <<= 1;",
			"            else cur = cur->nxt[!k], ans <<= 1, ans++;",
			"        }",
			"        return ans;",
			"    }",
			"    void del(node *cur){",
			"        for (int i = 0; i < 2; i++) if (cur->nxt[i]) del(cur->nxt[i]);",
			"        delete (cur);",
			"    }",
			"    void del(int val){",
			"        if(!search(val)) return;",
			"        node *cur = root;",
			"        cur->sz--;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int b = val >> i & 1;",
			"            if (cur->nxt[b] == NULL) return;",
			"            else if(cur->nxt[b]->sz == 1){",
			"                cur->nxt[b] = NULL;",
			"                return;",
			"            }",
			"            cur = cur->nxt[b];",
			"            cur->sz--;",
			"        }",
			"    }",
			"};"
		],
		"description": "Binary Trie"
	},
	"Solve 2-SAT": {
		"prefix": "twosat",
		"body": [
			"struct two_sat{",
			"    int n;",
			"    vector<vector<int>> g,rg;",
			"    vector<int> comp,ans,vis;",
			"    stack<int> stk;",
			"    ",
			"    two_sat(int _n) : n(_n), g(2*_n), rg(2*_n), comp(2*_n), ans(_n), vis(2*_n) {}",
			"    void add_edge(int u,int v){",
			"        g[u].push_back(v);",
			"        rg[v].push_back(u);",
			"    }",
			"    ",
			"    void add_or(int u,bool f,int v,bool g){     //at least one is true - or",
			"        add_edge(u + (f?n:0), v + (g?0:n));",
			"        add_edge(v + (g?n:0), u + (f?0:n));",
			"    }",
			"    void add_xor(int u,bool f,int v,bool g){    //exactly one is true - xor",
			"        add_or(u,f,v,g);",
			"        add_or(u,!f,v,!g);",
			"    }",
			"    void add_and(int u,bool f,int v,bool g){    //both have have same value - xnor",
			"        add_or(u,!f,v,g);",
			"        add_or(u,f,v,!g);",
			"    }",
			"    ",
			"    void dfs(int u){",
			"        vis[u] = 1;",
			"        for(auto &v : g[u]){",
			"            if(!vis[v]) dfs(v);",
			"        }",
			"        stk.push(u);",
			"    }",
			"    ",
			"    void scc(int u,int id){",
			"        vis[u] = 1;",
			"        comp[u] = id;",
			"        for(auto &v : rg[u]){",
			"            if(!vis[v]) scc(v,id);",
			"        }",
			"    }",
			"    ",
			"    bool satisfiable(){",
			"        for(auto &i:vis) i = 0;",
			"        for(int i = 0;i<2*n;i++) if(!vis[i]) dfs(i);",
			"        for(auto &i:vis) i = 0;",
			"        int id = 0;",
			"        while(!stk.empty()){",
			"            int v = stk.top();stk.pop();",
			"            if(!vis[v]) scc(v,id++);",
			"        }",
			"        ",
			"        for(int i = 0;i<n;i++){",
			"            if(comp[i] == comp[i+n]) return false;",
			"            ans[i] = comp[i] > comp[i+n];",
			"        }",
			"        return true;",
			"    }",
			"};"
		],
		"description": "Solve 2-SAT"
	},
	"Sum_Over_Subsets_DP": {
		"prefix": "sosdp",
		"body": [
			"const int LOG = 22;",
			"void forward1(vl &dp){      //pull contribution from its subsets",
			"    for(int bit = 0; bit < LOG; bit++)",
			"        for(int i = 0; i < MAXN; i++)",
			"            if(i&(1<<bit)) dp[i] += dp[i^(1<<bit)];",
			"}",
			"void backward1(vl &dp){",
			"    for(int bit = 0; bit < LOG; bit++)",
			"        for(int i = MAXN-1; i >= 0; i--)",
			"            if(i&(1<<bit)) dp[i] -= dp[i^(1<<bit)];",
			"}",
			"void forward2(vl &dp){      //push contribution to its subsets",
			"    for(int bit = 0;bit < LOG;bit++)",
			"        for(int i = MAXN-1; i >= 0; i--)",
			"            if(i&(1<<bit)) dp[i^(1<<bit)] += dp[i];",
			"}",
			"void backward2(vl &dp){",
			"    for(int bit = 0;bit < LOG;bit++)",
			"        for(int i = 0; i < MAXN; i++)",
			"            if(i&(1<<bit)) dp[i^(1<<bit)] -= dp[i];",
			"}"
		],
		"description": "Sum_Over_Subsets_DP"
	},
	"Least Common Ancestor": {
		"prefix": "lca",
		"body": [
			"struct LCA{",
			"  const int LOG = 30;",
			"  vector<vector<int>> par, adj;",
			"  vector<int> sub,dep,tin,tout;",
			"  int n,timer;",
			"  ",
			"  LCA(int _n){",
			"    n = _n+5;",
			"    par.assign(n,vector<int>(LOG));",
			"    adj.resize(n);",
			"    sub.resize(n);",
			"    dep.resize(n);",
			"    tin.resize(n);",
			"    tout.resize(n);",
			"  }",
			"  void add_edge(int u,int v){",
			"    adj[u].push_back(v);",
			"    adj[v].push_back(u);",
			"  }",
			"  void dfs(int u,int p,int depth){",
			"    sub[u] = 1;",
			"    dep[u] = depth;",
			"    par[u][0] = p;",
			"    tin[u] = ++timer;",
			"    for(auto &v:adj[u]) if(v!=p){",
			"        dfs(v,u,depth+1);",
			"        sub[u] += sub[u];",
			"    }",
			"    tout[u] = timer;",
			"  }",
			"  void root(int root,int def_p = 0){",
			"    timer = -1;",
			"    dfs(root,def_p,0);",
			"    for(int d = 1;d < LOG;d++){",
			"        for(int i = 0;i<n;i++){",
			"            par[i][d] = par[par[i][d-1]][d-1];",
			"        }",
			"    }",
			"  }",
			"  int go_up(int v,int k){",
			"    if(k > dep[v]) return -1;",
			"    for(int d = LOG-1 ;d>=0;d--){",
			"        if(k & (1<<d)) v = par[v][d];",
			"    }",
			"    return v;",
			"  }",
			"  int get_lca(int u,int v){",
			"    if(dep[u] < dep[v]) swap(u,v);",
			"    int k = dep[u]-dep[v];",
			"    u = go_up(u,k);",
			"    if(u==v) return u;",
			"    for(int d = LOG-1;d>=0;d--){",
			"        if(par[u][d] == par[v][d]) continue;",
			"        u = par[u][d];",
			"        v = par[v][d];",
			"    }",
			"    return par[u][0];",
			"  }",
			"  int get_dist(int u,int v){",
			"    return dep[u]+dep[v]-2*dep[get_lca(u,v)];",
			"  }",
			"};"
		],
		"description": "Least Common Ancestor"
	},
	"Heavy Light Decomposition": {
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"  int n;",
			"  vector<int> siz, top, dep, par, in, out, seq;",
			"  vector<vector<int>> adj;",
			"  int timer;",
			"  ",
			"  HLD() {}",
			"  HLD(int n) {",
			"    init(n);",
			"  }",
			"  void init(int n) {",
			"    this->n = n;",
			"    siz.resize(n);",
			"    top.resize(n);",
			"    dep.resize(n);",
			"    par.resize(n);",
			"    in.resize(n);",
			"    out.resize(n);",
			"    seq.resize(n);",
			"    timer = -1;",
			"    adj.assign(n, {});",
			"  }",
			"  void addEdge(int u, int v) {",
			"    adj[u].push_back(v);",
			"    adj[v].push_back(u);",
			"  }",
			"  void work(int root = 0) {",
			"    top[root] = root;",
			"    dep[root] = 0;",
			"    par[root] = -1;",
			"    dfs1(root);",
			"    dfs2(root);",
			"  }",
			"  void dfs1(int u) {",
			"    if (par[u] != -1) {",
			"      adj[u].erase(find(adj[u].begin(), adj[u].end(), par[u]));",
			"    }",
			"    ",
			"    siz[u] = 1;",
			"    for (auto &v : adj[u]) {",
			"      par[v] = u;",
			"      dep[v] = dep[u] + 1;",
			"      dfs1(v);",
			"      siz[u] += siz[v];",
			"      if (siz[v] > siz[adj[u][0]]) {",
			"        swap(v, adj[u][0]);",
			"      }",
			"    }",
			"  }",
			"  void dfs2(int u) {",
			"    in[u] = ++timer;",
			"    seq[in[u]] = u;",
			"    for (auto v : adj[u]) {",
			"      top[v] = v == adj[u][0] ? top[u] : v;",
			"      dfs2(v);",
			"    }",
			"    out[u] = timer;",
			"  }",
			"  int lca(int u, int v) {",
			"    while (top[u] != top[v]) {",
			"      if (dep[top[u]] > dep[top[v]]) {",
			"        u = par[top[u]];",
			"      } else {",
			"        v = par[top[v]];",
			"      }",
			"    }",
			"    return dep[u] < dep[v] ? u : v;",
			"  }",
			"  ",
			"  int dist(int u, int v) {",
			"    return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
			"  }",
			"  ",
			"  int jump(int u, int k) {",
			"    if (dep[u] < k) {",
			"      return -1;",
			"    }",
			"    ",
			"    int d = dep[u] - k;",
			"    ",
			"    while (dep[top[u]] > d) {",
			"      u = par[top[u]];",
			"    }",
			"    ",
			"    return seq[in[u] - dep[u] + d];",
			"  }",
			"  ",
			"  bool isAncester(int u, int v) {",
			"    return in[u] <= in[v] && in[v] <= out[u];",
			"  }",
			"  ",
			"  int rootedParent(int u, int v) {",
			"    swap(u, v);",
			"    if (u == v) {",
			"      return u;",
			"    }",
			"    if (!isAncester(u, v)) {",
			"      return par[u];",
			"    }",
			"    auto it = upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {",
			"      return in[x] < in[y];",
			"    }) - 1;",
			"    return *it;",
			"  }",
			"  ",
			"  int rootedSize(int u, int v) {",
			"    if (u == v) {",
			"      return n;",
			"    }",
			"    if (!isAncester(v, u)) {",
			"      return siz[v];",
			"    }",
			"    return n - siz[rootedParent(u, v)];",
			"  }",
			"  ",
			"  int rootedLca(int a, int b, int c) {",
			"    return lca(a, b) ^ lca(b, c) ^ lca(c, a);",
			"  }",
			"};"
		],
		"description": "Heavy Light Decomposition"
	},
	"String processing": {
		"prefix": "kmp",
		"body": [
			"struct Str{",
			"    int n;",
			"    string s;",
			"    Str() {};",
			"    Str(string &s_){",
			"        n = s_.length();",
			"        s = s_;",
			"    }",
			"    vector<int> get_lps(){",
			"        vector<int> lps(n);",
			"        int i = 1, len = 0;",
			"        while(i<n){",
			"            if(s[i] == s[len]) lps[i++] = ++len;",
			"            else if(len) len = lps[len-1];",
			"            else i++;",
			"        }",
			"        return lps;",
			"    }",
			"    vector<int> get_z(){",
			"        vector<int> z(n);",
			"        int L = 0, R = 0;",
			"        for(int i = 1;i<n;i++){",
			"            if(i < R) z[i] = min(R-i,z[i-L]);",
			"            while(i + z[i] < n && s[z[i]] == s[i+z[i]]) z[i]++;",
			"            if(i + z[i] > R){",
			"                L = i;",
			"                R = i+z[i];",
			"            }",
			"        }",
			"        return z;",
			"    }",
			"    vector<int> search(string &p){",
			"        int m = p.length();",
			"        Str pat(p);",
			"        vector<int> lps = pat.get_lps();",
			"        vector<int> ans;",
			"        int i = 0,j = 0;",
			"        while(i<n){",
			"            if(s[i] == p[j]) i++,j++;",
			"            else if(j) j = lps[j-1];",
			"            else i++;",
			"            if(j == m){",
			"                ans.push_back(i-j);",
			"                j = lps[j-1];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "String processing"
	},
	"Find Running Median of a set of numbers": {
		"prefix": "runningMedian",
		"body": [
			"struct Median{",
			"    multiset<int> l,r;",
			"    ",
			"    void balance(){",
			"        if(l.size() < r.size()){",
			"            int x = *r.begin();",
			"            l.insert(x);",
			"            r.erase(r.find(x));",
			"        }",
			"        if(l.size() > r.size()+1){",
			"            int x = *l.rbegin();",
			"            r.insert(x);",
			"            l.erase(l.find(x));",
			"        }",
			"    }",
			"    void insert(int x){",
			"        if(l.empty()) l.insert(x);",
			"        else if(x <= *l.rbegin()) l.insert(x);",
			"        else r.insert(x);",
			"        balance();",
			"    }",
			"    void remove(int x){",
			"        if(r.find(x) != r.end()){",
			"            r.erase(r.find(x));",
			"        }",
			"        else l.erase(l.find(x));",
			"        ",
			"        balance();",
			"    }",
			"    int get(){",
			"        int n = l.size() + r.size();",
			"        if(n == 0) return -1;",
			"        if(n&1) return *l.rbegin();",
			"        else{",
			"            ll x = *l.rbegin() + *r.begin();",
			"            return (x*500000004)%mod;",
			"        }",
			"    }",
			"};"
		],
		"description": "Find Running Median of a set of numbers"
	},
	"Find Running Mode of a set of numbers": {
		"prefix": "runningMode",
		"body": [
			"struct Mode{",
			"    map<int,int> f;",
			"    set<pair<int,int>> st;",
			"    void insert(int x){",
			"        if(st.find({f[x],x}) != st.end()){",
			"            st.erase({f[x],x});",
			"        }",
			"        f[x]++;",
			"        st.insert({f[x],x});",
			"    }",
			"    void remove(int x){",
			"        if(st.find({f[x],x}) != st.end()){",
			"            st.erase({f[x],x});",
			"        }",
			"        f[x]--;",
			"        if(f[x]>0) st.insert({f[x],x});",
			"    }",
			"    int getMode(){",
			"        if(st.empty()) return -1;",
			"        return st.rbegin()->second;",
			"    }",
			"    int getModeFreq(){",
			"        if(st.empty()) return 0;",
			"        return st.rbegin()->first;",
			"    }",
			"};"
		],
		"description": "Find Running Mode of a set of numbers"
	}
}
