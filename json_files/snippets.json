{
	"Boilerplate": {
		"prefix": "Boilerplate",
		"body": [
			"/**",
			" *    Author:  Rohit Meena",
			" *    Created: 12.10.2024 01:22:43",
			" *    Link: https://github.com/Cyber-Hunterr/Snippets",
			"**/",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"#define sortall(x) sort(all(x))",
			"#define sz(x) (int)(x.size())",
			"#define nl '\\n'",
			"",
			"#ifdef JAI_SHREE_KRISHNA",
			"  #include <debug.h>",
			"#else",
			"  #define dbg(x...) 32",
			"#endif",
			"",
			"typedef long long ll;",
			"typedef unsigned long long ull;",
			"typedef long double ld;",
			"typedef pair<int, int> pii;",
			"typedef pair<ll, ll> pll;",
			"typedef vector<int> vi;",
			"typedef vector<ll> vl;",
			"typedef vector<vi> vvi;",
			"typedef vector<vl> vvl;",
			"typedef vector<pii> vii;",
			"typedef vector<pll> vll;",
			"",
			"// Operator overloads",
			"template<typename T1, typename T2> istream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.first >> p.second); }",
			"template<typename T> istream& operator>>(istream &istream, vector<T> &v){for (auto &it : v)cin >> it;return istream;}",
			"template<typename T1, typename T2> ostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.first << \" \" << p.second); }",
			"template<typename T> ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }",
			"",
			"const ll mod = 1000000007;",
			"const ld eps = 1e-9;",
			"const ll inf = 1e18;",
			"const int MAXN = 1e6 + 1;",
			"",
			"/**************************** --- Add Global Variables & Functions --- ****************************/",
			"string yes = \"YES\\n\",no = \"NO\\n\";",
			"/**************************** ---------------------------------------- ****************************/",
			"",
			"void precompute(){",
			"  ",
			"}",
			"void solve(){",
			"  ${0}",
			"}",
			"",
			"int main() {",
			"  ios_base::sync_with_stdio(false);",
			"  cin.tie(NULL);",
			"  #ifdef JAI_SHREE_KRISHNA",
			"    freopen(\"input.txt\",\"r\",stdin);",
			"    freopen(\"output.txt\",\"w\",stdout);",
			"    freopen(\"error.txt\",\"w\",stderr);",
			"  #endif",
			"  int tc=1;",
			"  ${1}cin>>tc;",
			"  precompute();",
			"  for(int i = 1; i <= tc; i++){",
			"    // cout<<\"Case #\"<<i<<\": \";",
			"    solve();",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "Boilerplate"
	},
	"Pragma": {
		"prefix": "pragma",
		"body": [
			"#pragma GCC optimize(\"O3,unroll-loops\")",
			"#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
		],
		"description": "Pragma"
	},
	"Simple": {
		"prefix": "simple",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#ifdef JAI_SHREE_KRISHNA",
			"#include <debug.h>",
			"#else",
			"#define dbg(x...) 32",
			"#endif",
			"",
			"#define ll long long",
			"",
			"void solve(){",
			"  ${0}",
			"}",
			"",
			"int main() {",
			"  ios_base::sync_with_stdio(false);",
			"  cin.tie(NULL);",
			"  int tc=1;",
			"  ${1}cin>>tc;",
			"  for(int i = 1; i <= tc; i++){",
			"    // cout<<\"Case #\"<<i<<\": \";",
			"    solve();",
			"  }",
			"  return 0;",
			"}"
		],
		"description": "Simple"
	},
	"Forward For Loop": {
		"prefix": "for",
		"body": [
			"for(int ${1:i} = ${2:0};${1:i} < ${3:n};${1:i}++){",
			"  ${0}",
			"}"
		],
		"description": "Forward For Loop"
	},
	"Reverse For Loop": {
		"prefix": "rfor",
		"body": [
			"for(int ${1:i} = ${2:n-1};${1:i} >= ${3:0};${1:i}--){",
			"  ${0}",
			"}"
		],
		"description": "Reverse For Loop"
	},
	"Range based For Loop": {
		"prefix": "forrange",
		"body": [
			"for(auto &${1:i} : ${2:v}){",
			"  ${0}",
			"}"
		],
		"description": "Range based For Loop"
	},
	"Binary Exponentiation": {
		"prefix": "binpow",
		"body": [
			"long long binpow(long long a, long long b, long long p = mod){",
			"  long long res = 1;",
			"  while (b > 0){",
			"    if(b & 1) res = (res * a) % p;",
			"    a = (a * a) % p;",
			"    b >>= 1;",
			"  }",
			"  return res;",
			"}"
		],
		"description": "Binary Exponentiation"
	},
	"Seive of Eratosthenes": {
		"prefix": "sieve",
		"body": [
			"for (int i = 2; i < MAXN; i++){",
			"  if(lp[i] == 0){",
			"    lp[i] = i;",
			"    for (int j = 2*i; j < MAXN; j+=i){",
			"      if(lp[j] == 0) lp[j] = i;",
			"    }",
			"  }",
			"}",
			"vi lp(MAXN);"
		],
		"description": "Seive of Eratosthenes"
	},
	"Disjoint Set Union": {
		"prefix": "dsu",
		"body": [
			"struct DSU{",
			"  int c;",
			"  vector<int> par, size;",
			"  DSU(int _n){",
			"    c = _n;",
			"    par.resize(_n + 1);",
			"    size.assign(_n + 1, 1);",
			"    iota(par.begin(), par.end(), 0);",
			"  }",
			"  int leader(int u){",
			"    return u == par[u] ? u : par[u] = leader(par[u]);",
			"  }",
			"  bool same(int u,int v){",
			"    return leader(u) == leader(v);",
			"  }",
			"  int get_size(int u){",
			"    return size[leader(u)];",
			"  }",
			"  int count(){",
			"    return c;",
			"  }",
			"  bool merge(int u,int v){",
			"    if((u = leader(u)) == (v = leader(v))) return false;",
			"    c--;",
			"    if(size[u] < size[v]) swap(u,v);",
			"    par[v] = u;",
			"    size[u] += size[v];",
			"    return true;",
			"  }",
			"};"
		],
		"description": "Disjoint Set Union"
	},
	"Policy Based Data Structures": {
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"template <typename K, typename V, typename Comp = std::less<K>> using ordered_map = __gnu_pbds::tree<K, V, Comp, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
			"template <typename K, typename Comp = std::less<K>> using ordered_set = ordered_map<K, __gnu_pbds::null_type, Comp>;",
			"// s.find_by_order(k)     ->  kth element",
			"// s.order_of_key(k)      ->  number of elements less than k (first elements in case of map)"
		],
		"description": "Policy Based Data Structures"
	},
	"Hashmaps with splitmix64 Hash": {
		"prefix": "hashmap",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"struct splitmix64_hash {",
			"  static uint64_t splitmix64(uint64_t x) {",
			"    // http://xorshift.di.unimi.it/splitmix64.c",
			"    x += 0x9e3779b97f4a7c15;",
			"    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"    return x ^ (x >> 31);",
			"  }",
			"",
			"  size_t operator()(uint64_t x) const {",
			"    static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
			"    return splitmix64(x + FIXED_RANDOM);",
			"  }",
			"};",
			"",
			"template <typename K, typename V, typename Hash = splitmix64_hash>",
			"using HashMap = __gnu_pbds::gp_hash_table<K, V, Hash>;",
			"",
			"template <typename K, typename Hash = splitmix64_hash>",
			"using HashSet = HashMap<K, __gnu_pbds::null_type, Hash>;"
		],
		"description": "Hashmaps with splitmix64 Hash"
	},
	"Node and update class for segtree": {
		"prefix": "infotag",
		"body": [
			"struct Tag {",
			"  int add = 0;",
			"  ",
			"  void apply(const Tag &t) & {",
			"    add += t.add;",
			"  }",
			"};",
			"struct Info {",
			"  int mn = 1e9;",
			"  void apply(const Tag &t) & {",
			"    mn += t.add;",
			"  }",
			"};",
			" ",
			"Info operator+(Info &l, Info &r) {",
			"  return min(l.mn, r.mn);",
			"}"
		],
		"description": "Node and update class for segtree"
	},
	"Random Number Generator": {
		"prefix": "random",
		"body": [
			"mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
			"long long rand(long long a, long long b) { return uniform_int_distribution<long long>(a, b)(rng); }"
		],
		"description": "Random Number Generator"
	},
	"Modular Integer": {
		"prefix": "mint",
		"body": [
			"template <typename T>",
			"T inverse(T a, T m) {",
			"  T u = 0, v = 1;",
			"  while (a != 0) {",
			"    T t = m / a;",
			"    m -= t * a; swap(a, m);",
			"    u -= t * v; swap(u, v);",
			"  }",
			"  assert(m == 1);",
			"  return u;",
			"}",
			"",
			"template <typename T>",
			"class Modular {",
			" public:",
			"  using Type = typename decay<decltype(T::value)>::type;",
			"",
			"  constexpr Modular() : value() {}",
			"  template <typename U>",
			"  Modular(const U& x) {",
			"    value = normalize(x);",
			"  }",
			"",
			"  template <typename U>",
			"  static Type normalize(const U& x) {",
			"    Type v;",
			"    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);",
			"    else v = static_cast<Type>(x % mod());",
			"    if (v < 0) v += mod();",
			"    return v;",
			"  }",
			"",
			"  const Type& operator()() const { return value; }",
			"  template <typename U>",
			"  explicit operator U() const { return static_cast<U>(value); }",
			"  constexpr static Type mod() { return T::value; }",
			"",
			"  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
			"  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
			"  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
			"  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
			"  Modular& operator++() { return *this += 1; }",
			"  Modular& operator--() { return *this -= 1; }",
			"  Modular operator++(int) { Modular result(*this); *this += 1; return result; }",
			"  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }",
			"  Modular operator-() const { return Modular(-value); }",
			"",
			"  template <typename U = T>",
			"  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
			"    return *this;",
			"  }",
			"  template <typename U = T>",
			"  typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"    long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());",
			"    value = normalize(value * rhs.value - q * mod());",
			"    return *this;",
			"  }",
			"  template <typename U = T>",
			"  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
			"    value = normalize(value * rhs.value);",
			"    return *this;",
			"  }",
			"",
			"  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
			"",
			"  friend const Type& abs(const Modular& x) { return x.value; }",
			"",
			"  template <typename U>",
			"  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
			"",
			"  template <typename U>",
			"  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
			"",
			"  template <typename V, typename U>",
			"  friend V& operator>>(V& stream, Modular<U>& number);",
			"",
			" private:",
			"  Type value;",
			"};",
			"",
			"template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
			"template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
			"template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
			"",
			"template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
			"template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
			"",
			"template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
			"",
			"template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
			"template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
			"",
			"template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
			"template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
			"",
			"template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
			"template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
			"",
			"template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
			"template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
			"",
			"template<typename T, typename U>",
			"Modular<T> power(const Modular<T>& a, const U& b) {",
			"  assert(b >= 0);",
			"  Modular<T> x = a, res = 1;",
			"  U p = b;",
			"  while (p > 0) {",
			"    if (p & 1) res *= x;",
			"    x *= x;",
			"    p >>= 1;",
			"  }",
			"  return res;",
			"}",
			"",
			"template <typename T>",
			"bool IsZero(const Modular<T>& number) {",
			"  return number() == 0;",
			"}",
			"",
			"template <typename T>",
			"string to_string(const Modular<T>& number) {",
			"  return to_string(number());",
			"}",
			"",
			"// U == std::ostream? but done this way because of fastoutput",
			"template <typename U, typename T>",
			"U& operator<<(U& stream, const Modular<T>& number) {",
			"  return stream << number();",
			"}",
			"",
			"// U == std::istream? but done this way because of fastinput",
			"template <typename U, typename T>",
			"U& operator>>(U& stream, Modular<T>& number) {",
			"  typename common_type<typename Modular<T>::Type, long long>::type x;",
			"  stream >> x;",
			"  number.value = Modular<T>::normalize(x);",
			"  return stream;",
			"}",
			"",
			"constexpr int md = ${0};",
			"using Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;"
		],
		"description": "Modular Integer"
	},
	"Combinatorics": {
		"prefix": "combinatorics",
		"body": [
			"vector<Mint> fact(1, 1);",
			"vector<Mint> inv_fact(1, 1);",
			"",
			"Mint C(int n, int k = 0) {",
			"  if (k < 0 || k > n) {",
			"    return 0;",
			"  }",
			"  while ((int) fact.size() < n + 1) {",
			"    fact.push_back(fact.back() * (int) fact.size());",
			"    inv_fact.push_back(1 / fact.back());",
			"  }",
			"  return fact[n] * inv_fact[k] * inv_fact[n - k];",
			"}"
		],
		"description": "Combinatorics"
	},
	"Segment Tree": {
		"prefix": "segtree",
		"body": [
			"template<class Info>",
			"struct SegmentTree {",
			"  int n;",
			"  std::vector<Info> info;",
			"  SegmentTree() : n(0) {}",
			"  SegmentTree(int n_, Info v_ = Info()) {",
			"    init(n_, v_);",
			"  }",
			"  template<class T>",
			"  SegmentTree(std::vector<T> init_) {",
			"    init(init_);",
			"  }",
			"  void init(int n_, Info v_ = Info()) {",
			"    init(std::vector(n_, v_));",
			"  }",
			"  template<class T>",
			"  void init(std::vector<T> init_) {",
			"    n = init_.size();",
			"    info.assign(4 << std::__lg(n), Info());",
			"    std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"        if (r - l == 1) {",
			"            info[p] = init_[l];",
			"            return;",
			"        }",
			"        int m = (l + r) / 2;",
			"        build(2 * p, l, m);",
			"        build(2 * p + 1, m, r);",
			"        pull(p);",
			"    };",
			"    build(1, 0, n);",
			"  }",
			"  void pull(int p) {",
			"    info[p] = info[2 * p] + info[2 * p + 1];",
			"  }",
			"  void modify(int p, int l, int r, int x, const Info &v) {",
			"    if (r - l == 1) {",
			"      info[p] = v;",
			"      return;",
			"    }",
			"    int m = (l + r) / 2;",
			"    if (x < m) modify(2 * p, l, m, x, v);",
			"    else modify(2 * p + 1, m, r, x, v);",
			"    pull(p);",
			"  }",
			"  void modify(int p, const Info &v) {",
			"    modify(1, 0, n, p, v);",
			"  }",
			"  Info rangeQuery(int p, int l, int r, int x, int y) {",
			"    if (l >= y || r <= x) return Info();",
			"    if (l >= x && r <= y) return info[p];",
			"    int m = (l + r) / 2;",
			"    return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
			"  }",
			"  Info rangeQuery(int l, int r) {",
			"    return rangeQuery(1, 0, n, l, r);",
			"  }",
			"  template<class F>",
			"  int findFirst(int p, int l, int r, int x, int y, F pred) {",
			"    if (l >= y || r <= x || !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"    ",
			"    int m = (l + r) / 2;",
			"    int res = findFirst(2 * p, l, m, x, y, pred);",
			"    if (res == -1) {",
			"      res = findFirst(2 * p + 1, m, r, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findFirst(int l, int r, F pred) {",
			"    return findFirst(1, 0, n, l, r, pred);",
			"  }",
			"  template<class F>",
			"  int findLast(int p, int l, int r, int x, int y, F pred) {",
			"    if (l >= y || r <= x || !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"",
			"    int m = (l + r) / 2;",
			"    int res = findLast(2 * p + 1, m, r, x, y, pred);",
			"    if (res == -1) {",
			"      res = findLast(2 * p, l, m, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findLast(int l, int r, F pred) {",
			"    return findLast(1, 0, n, l, r, pred);",
			"  }",
			"};"
		],
		"description": "Segment Tree"
	},
	"Lazy Segment Tree": {
		"prefix": "lsegtree",
		"body": [
			"template<class Info, class Tag>",
			"struct LazySegmentTree {",
			"  int n;",
			"  std::vector<Info> info;",
			"  std::vector<Tag> tag;",
			"  LazySegmentTree() : n(0) {}",
			"  LazySegmentTree(int n_, Info v_ = Info()) {",
			"    init(n_, v_);",
			"  }",
			"  template<class T>",
			"  LazySegmentTree(std::vector<T> init_) {",
			"    init(init_);",
			"  }",
			"  void init(int n_, Info v_ = Info()) {",
			"    init(std::vector(n_, v_));",
			"  }",
			"  template<class T>",
			"  void init(std::vector<T> init_) {",
			"    n = init_.size();",
			"    info.assign(4 << std::__lg(n), Info());",
			"    tag.assign(4 << std::__lg(n), Tag());",
			"    std::function<void(int, int, int)> build = [&](int p, int l, int r) {",
			"      if (r - l == 1) {",
			"        info[p] = init_[l];",
			"        return;",
			"      }",
			"      int m = (l + r) / 2;",
			"      build(2 * p, l, m);",
			"      build(2 * p + 1, m, r);",
			"      pull(p);",
			"    };",
			"    build(1, 0, n);",
			"  }",
			"  void pull(int p) {",
			"    info[p] = info[2 * p] + info[2 * p + 1];",
			"  }",
			"  void apply(int p, const Tag &v) {",
			"    info[p].apply(v);",
			"    tag[p].apply(v);",
			"  }",
			"  void push(int p) {",
			"    apply(2 * p, tag[p]);",
			"    apply(2 * p + 1, tag[p]);",
			"    tag[p] = Tag();",
			"  }",
			"  void modify(int p, int l, int r, int x, const Info &v) {",
			"    if (r - l == 1) {",
			"      info[p] = v;",
			"      return;",
			"    }",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    if (x < m) modify(2 * p, l, m, x, v);",
			"    else modify(2 * p + 1, m, r, x, v);",
			"    pull(p);",
			"  }",
			"  void modify(int p, const Info &v) {",
			"    modify(1, 0, n, p, v);",
			"  }",
			"  Info rangeQuery(int p, int l, int r, int x, int y) {",
			"    if (l >= y || r <= x) return Info();",
			"    if (l >= x && r <= y) return info[p];",
			"    ",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);",
			"  }",
			"  Info rangeQuery(int l, int r) {",
			"    return rangeQuery(1, 0, n, l, r);",
			"  }",
			"  void rangeApply(int p, int l, int r, int x, int y, const Tag &v) {",
			"    if (l >= y || r <= x) return;",
			"    if (l >= x && r <= y) {",
			"      apply(p, v);",
			"      return;",
			"    }",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    rangeApply(2 * p, l, m, x, y, v);",
			"    rangeApply(2 * p + 1, m, r, x, y, v);",
			"    pull(p);",
			"  }",
			"  void rangeApply(int l, int r, const Tag &v) {",
			"    return rangeApply(1, 0, n, l, r, v);",
			"  }",
			"  template<class F>",
			"  int findFirst(int p, int l, int r, int x, int y, F &&pred) {",
			"    if (l >= y || r <= x) return -1;",
			"    if (l >= x && r <= y && !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"    ",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    int res = findFirst(2 * p, l, m, x, y, pred);",
			"    if (res == -1) {",
			"      res = findFirst(2 * p + 1, m, r, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findFirst(int l, int r, F &&pred) {",
			"    return findFirst(1, 0, n, l, r, pred);",
			"  }",
			"  template<class F>",
			"  int findLast(int p, int l, int r, int x, int y, F &&pred) {",
			"    if (l >= y || r <= x) return -1;",
			"    if (l >= x && r <= y && !pred(info[p])) return -1;",
			"    if (r - l == 1) return l;",
			"    ",
			"    int m = (l + r) / 2;",
			"    push(p);",
			"    int res = findLast(2 * p + 1, m, r, x, y, pred);",
			"    if (res == -1) {",
			"      res = findLast(2 * p, l, m, x, y, pred);",
			"    }",
			"    return res;",
			"  }",
			"  template<class F>",
			"  int findLast(int l, int r, F &&pred) {",
			"    return findLast(1, 0, n, l, r, pred);",
			"  }",
			"};"
		],
		"description": "Lazy Segment Tree"
	},
	"2D Matrix": {
		"prefix": "matrix",
		"body": [
			"template <typename T>",
			"struct Matrix {",
			"  int n,m;",
			"  vector<vector<T>> v;",
			"  Matrix() {}",
			"  Matrix(int _n,int _m, bool Identity = false){",
			"    n = _n; m = _m;",
			"    v.assign(n,vector<T>(m,0));",
			"    if(Identity){",
			"      assert(n == m);",
			"      for(int i = 0;i<n;i++) v[i][i] = 1;",
			"    }",
			"  }",
			"  Matrix(vector<vector<T>> _v){",
			"    n = _v.size();",
			"    m = n ? _v[0].size() : 0;",
			"    v = _v;",
			"  }",
			"  ",
			"  vector<T>& operator [] (int i){",
			"    return this->v[i];",
			"  }",
			"  ",
			"  Matrix operator + (Matrix &b){",
			"    assert(n == b.n && m == b.m);",
			"    Matrix ans(n,m);",
			"    for(int i = 0;i<n;i++){",
			"      for(int j = 0;j<m;j++){",
			"        ans[i][j] = v[i][j] + b[i][j];",
			"      }",
			"    }",
			"    return ans;",
			"  }",
			"  Matrix operator - (Matrix &b){",
			"    assert(n == b.n && m == b.m);",
			"    Matrix ans(n,m);",
			"    for(int i = 0;i<n;i++){",
			"      for(int j = 0;j<m;j++){",
			"        ans[i][j] = v[i][j] - b[i][j];",
			"      }",
			"    }",
			"    return ans;",
			"  }",
			"  Matrix operator * (Matrix &b){",
			"    assert(m == b.n);",
			"    Matrix ans(n,b.m);",
			"    for(int i = 0;i<n;i++){",
			"      for(int j = 0;j<b.m;j++){",
			"        for(int k = 0;k<m;k++){",
			"          ans[i][j] += v[i][k] * b[k][j];",
			"        }",
			"      }",
			"    }",
			"    return ans;",
			"  }",
			"  Matrix operator ^ (long long k){",
			"    assert(n == m);",
			"    Matrix ans(n,m,true),t = *this;",
			"    while(k){",
			"      if(k & 1) ans = ans * t;",
			"      t = t * t;",
			"      k >>= 1;",
			"    }",
			"    return ans;",
			"  }",
			"  Matrix & operator += (Matrix &b) { return *this = *this + b; }",
			"  Matrix & operator -= (Matrix &b) { return *this = *this - b; }",
			"  Matrix & operator *= (Matrix &b) { return *this = *this * b; }",
			"  Matrix & operator ^= (long long k) { return *this = *this ^ k; }",
			"  Matrix & operator == (Matrix &b) { return this->v == b.v; }",
			"  Matrix & operator != (Matrix &b) { return this->v != b.v; }",
			"};"
		],
		"description": "2D Matrix"
	},
	"Prefix trie": {
		"prefix": "trie",
		"body": [
			"struct Trie{",
			"    static const int ALPHA = 26;    //Number of alphabets;",
			"    static const char c = 'a';      //Starting alphabet;",
			"    struct node{",
			"        node* child[ALPHA];",
			"        int start,stop;",
			"        node(){",
			"            for(int i = 0;i<ALPHA;i++) child[i] = NULL;",
			"            start = stop = 0;",
			"        }",
			"    }*root;",
			"    ",
			"    Trie(){",
			"        root = new node();",
			"    }",
			"    void insert(string s){          //insert string into trie",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            if(!cur->child[s[i]-c]) cur->child[s[i]-c] = new node();",
			"            cur->start++;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        cur->start++;",
			"        cur->stop++;",
			"    }",
			"    bool search(string s){          //search if a string is present or not",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            if(!cur->child[s[i]-c]) return false;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        return cur->stop;",
			"    }",
			"    int count(string s){            //count how many words have prefix=s",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            if(!cur->child[s[i]-c]) return 0;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        return cur->start;",
			"    }",
			"    void dfs(node* cur){            //perform preorder dfs on trie",
			"        for(int i = 0;i<ALPHA;i++){",
			"            if(cur->child[i]){",
			"                cout<<char(c+i);",
			"                if(cur->child[i]->stop) cout<<\"# \";",
			"                else cout<<\" \";",
			"                dfs(cur->child[i]);",
			"            }",
			"        }",
			"    }",
			"    void del(string s){           //delete a word from trie",
			"        if(!search(s)) return;",
			"        node* cur = root;",
			"        for(int i = 0;i < sz(s);i++){",
			"            cur->start--;",
			"            cur = cur->child[s[i]-c];",
			"        }",
			"        cur->start--;",
			"        cur->stop--;",
			"    }",
			"};"
		],
		"description": "Prefix trie"
	},
	"Binary Trie": {
		"prefix": "bintrie",
		"body": [
			"struct BinTrie{",
			"    static const int B = 31;",
			"    struct node{",
			"        node *nxt[2];",
			"        int sz;",
			"        node(){",
			"            nxt[0] = nxt[1] = NULL;",
			"            sz = 0;",
			"        }",
			"    } *root;",
			"    BinTrie(){",
			"        root = new node();",
			"    }",
			"    void insert(int val){",
			"        node *cur = root;",
			"        cur->sz++;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int b = val >> i & 1;",
			"            if (cur->nxt[b] == NULL)",
			"                cur->nxt[b] = new node();",
			"            cur = cur->nxt[b];",
			"            cur->sz++;",
			"        }",
			"    }",
			"    bool search(int val){",
			"        node *cur = root;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int b = val >> i & 1;",
			"            if (cur->nxt[b] == NULL) return false;",
			"            cur = cur->nxt[b];",
			"        }",
			"        return true;",
			"    }",
			"    int query(int x, int k){ // number of values s.t. val ^ x < k",
			"        node *cur = root;",
			"        int ans = 0;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            if (cur == NULL) break;",
			"            int b1 = x >> i & 1, b2 = k >> i & 1;",
			"            if (b2 == 1){",
			"                if (cur->nxt[b1])",
			"                    ans += cur->nxt[b1]->sz;",
			"                cur = cur->nxt[!b1];",
			"            }",
			"            else cur = cur->nxt[b1];",
			"        }",
			"        return ans;",
			"    }",
			"    int get_max(int x){ // returns maximum of val ^ x",
			"        node *cur = root;",
			"        int ans = 0;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int k = x >> i & 1;",
			"            if (cur->nxt[!k]) cur = cur->nxt[!k], ans <<= 1, ans++;",
			"            else cur = cur->nxt[k], ans <<= 1;",
			"        }",
			"        return ans;",
			"    }",
			"    int get_min(int x){ // returns minimum of val ^ x",
			"        node *cur = root;",
			"        int ans = 0;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int k = x >> i & 1;",
			"            if (cur->nxt[k]) cur = cur->nxt[k], ans <<= 1;",
			"            else cur = cur->nxt[!k], ans <<= 1, ans++;",
			"        }",
			"        return ans;",
			"    }",
			"    void del(node *cur){",
			"        for (int i = 0; i < 2; i++) if (cur->nxt[i]) del(cur->nxt[i]);",
			"        delete (cur);",
			"    }",
			"    void del(int val){",
			"        if(!search(val)) return;",
			"        node *cur = root;",
			"        cur->sz--;",
			"        for (int i = B - 1; i >= 0; i--){",
			"            int b = val >> i & 1;",
			"            if (cur->nxt[b] == NULL) return;",
			"            else if(cur->nxt[b]->sz == 1){",
			"                cur->nxt[b] = NULL;",
			"                return;",
			"            }",
			"            cur = cur->nxt[b];",
			"            cur->sz--;",
			"        }",
			"    }",
			"};"
		],
		"description": "Binary Trie"
	},
	"Solve 2-SAT": {
		"prefix": "twosat",
		"body": [
			"struct two_sat{",
			"    int n;",
			"    vector<vector<int>> g,rg;",
			"    vector<int> comp,ans,vis;",
			"    stack<int> stk;",
			"    ",
			"    two_sat(int _n) : n(_n), g(2*_n), rg(2*_n), comp(2*_n), ans(_n), vis(2*_n) {}",
			"    void add_edge(int u,int v){",
			"        g[u].push_back(v);",
			"        rg[v].push_back(u);",
			"    }",
			"    ",
			"    void add_or(int u,bool f,int v,bool g){     //at least one is true - or",
			"        add_edge(u + (f?n:0), v + (g?0:n));",
			"        add_edge(v + (g?n:0), u + (f?0:n));",
			"    }",
			"    void add_xor(int u,bool f,int v,bool g){    //exactly one is true - xor",
			"        add_or(u,f,v,g);",
			"        add_or(u,!f,v,!g);",
			"    }",
			"    void add_and(int u,bool f,int v,bool g){    //both have have same value - xnor",
			"        add_or(u,!f,v,g);",
			"        add_or(u,f,v,!g);",
			"    }",
			"    ",
			"    void dfs(int u){",
			"        vis[u] = 1;",
			"        for(auto &v : g[u]){",
			"            if(!vis[v]) dfs(v);",
			"        }",
			"        stk.push(u);",
			"    }",
			"    ",
			"    void scc(int u,int id){",
			"        vis[u] = 1;",
			"        comp[u] = id;",
			"        for(auto &v : rg[u]){",
			"            if(!vis[v]) scc(v,id);",
			"        }",
			"    }",
			"    ",
			"    bool satisfiable(){",
			"        for(auto &i:vis) i = 0;",
			"        for(int i = 0;i<2*n;i++) if(!vis[i]) dfs(i);",
			"        for(auto &i:vis) i = 0;",
			"        int id = 0;",
			"        while(!stk.empty()){",
			"            int v = stk.top();stk.pop();",
			"            if(!vis[v]) scc(v,id++);",
			"        }",
			"        ",
			"        for(int i = 0;i<n;i++){",
			"            if(comp[i] == comp[i+n]) return false;",
			"            ans[i] = comp[i] > comp[i+n];",
			"        }",
			"        return true;",
			"    }",
			"};"
		],
		"description": "Solve 2-SAT"
	},
	"Sum_Over_Subsets_DP": {
		"prefix": "sosdp",
		"body": [
			"const int LOG = 22;",
			"void forward1(vl &dp){      //pull contribution from its subsets",
			"    for(int bit = 0; bit < LOG; bit++)",
			"        for(int i = 0; i < MAXN; i++)",
			"            if(i&(1<<bit)) dp[i] += dp[i^(1<<bit)];",
			"}",
			"void backward1(vl &dp){",
			"    for(int bit = 0; bit < LOG; bit++)",
			"        for(int i = MAXN-1; i >= 0; i--)",
			"            if(i&(1<<bit)) dp[i] -= dp[i^(1<<bit)];",
			"}",
			"void forward2(vl &dp){      //push contribution to its subsets",
			"    for(int bit = 0;bit < LOG;bit++)",
			"        for(int i = MAXN-1; i >= 0; i--)",
			"            if(i&(1<<bit)) dp[i^(1<<bit)] += dp[i];",
			"}",
			"void backward2(vl &dp){",
			"    for(int bit = 0;bit < LOG;bit++)",
			"        for(int i = 0; i < MAXN; i++)",
			"            if(i&(1<<bit)) dp[i^(1<<bit)] -= dp[i];",
			"}"
		],
		"description": "Sum_Over_Subsets_DP"
	},
	"Least Common Ancestor": {
		"prefix": "lca",
		"body": [
			"struct LCA{",
			"  const int LOG = 30;",
			"  vector<vector<int>> par, adj;",
			"  vector<int> sub,dep,tin,tout;",
			"  int n,timer;",
			"  ",
			"  LCA(int _n){",
			"    n = _n+5;",
			"    par.assign(n,vector<int>(LOG));",
			"    adj.resize(n);",
			"    sub.resize(n);",
			"    dep.resize(n);",
			"    tin.resize(n);",
			"    tout.resize(n);",
			"  }",
			"  void add_edge(int u,int v){",
			"    adj[u].push_back(v);",
			"    adj[v].push_back(u);",
			"  }",
			"  void dfs(int u,int p,int depth){",
			"    sub[u] = 1;",
			"    dep[u] = depth;",
			"    par[u][0] = p;",
			"    tin[u] = ++timer;",
			"    for(auto &v:adj[u]) if(v!=p){",
			"        dfs(v,u,depth+1);",
			"        sub[u] += sub[u];",
			"    }",
			"    tout[u] = timer;",
			"  }",
			"  void root(int root,int def_p = 0){",
			"    timer = -1;",
			"    dfs(root,def_p,0);",
			"    for(int d = 1;d < LOG;d++){",
			"        for(int i = 0;i<n;i++){",
			"            par[i][d] = par[par[i][d-1]][d-1];",
			"        }",
			"    }",
			"  }",
			"  int go_up(int v,int k){",
			"    if(k > dep[v]) return -1;",
			"    for(int d = LOG-1 ;d>=0;d--){",
			"        if(k & (1<<d)) v = par[v][d];",
			"    }",
			"    return v;",
			"  }",
			"  int get_lca(int u,int v){",
			"    if(dep[u] < dep[v]) swap(u,v);",
			"    int k = dep[u]-dep[v];",
			"    u = go_up(u,k);",
			"    if(u==v) return u;",
			"    for(int d = LOG-1;d>=0;d--){",
			"        if(par[u][d] == par[v][d]) continue;",
			"        u = par[u][d];",
			"        v = par[v][d];",
			"    }",
			"    return par[u][0];",
			"  }",
			"  int get_dist(int u,int v){",
			"    return dep[u]+dep[v]-2*dep[get_lca(u,v)];",
			"  }",
			"};"
		],
		"description": "Least Common Ancestor"
	},
	"Heavy Light Decomposition": {
		"prefix": "hld",
		"body": [
			"struct HLD {",
			"  int n;",
			"  vector<int> siz, top, dep, par, in, out, seq;",
			"  vector<vector<int>> adj;",
			"  int timer;",
			"  ",
			"  HLD() {}",
			"  HLD(int n) {",
			"    init(n);",
			"  }",
			"  void init(int n) {",
			"    this->n = n;",
			"    siz.resize(n);",
			"    top.resize(n);",
			"    dep.resize(n);",
			"    par.resize(n);",
			"    in.resize(n);",
			"    out.resize(n);",
			"    seq.resize(n);",
			"    timer = -1;",
			"    adj.assign(n, {});",
			"  }",
			"  void addEdge(int u, int v) {",
			"    adj[u].push_back(v);",
			"    adj[v].push_back(u);",
			"  }",
			"  void work(int root = 0) {",
			"    top[root] = root;",
			"    dep[root] = 0;",
			"    par[root] = -1;",
			"    dfs1(root);",
			"    dfs2(root);",
			"  }",
			"  void dfs1(int u) {",
			"    if (par[u] != -1) {",
			"      adj[u].erase(find(adj[u].begin(), adj[u].end(), par[u]));",
			"    }",
			"    ",
			"    siz[u] = 1;",
			"    for (auto &v : adj[u]) {",
			"      par[v] = u;",
			"      dep[v] = dep[u] + 1;",
			"      dfs1(v);",
			"      siz[u] += siz[v];",
			"      if (siz[v] > siz[adj[u][0]]) {",
			"        swap(v, adj[u][0]);",
			"      }",
			"    }",
			"  }",
			"  void dfs2(int u) {",
			"    in[u] = ++timer;",
			"    seq[in[u]] = u;",
			"    for (auto v : adj[u]) {",
			"      top[v] = v == adj[u][0] ? top[u] : v;",
			"      dfs2(v);",
			"    }",
			"    out[u] = timer;",
			"  }",
			"  int lca(int u, int v) {",
			"    while (top[u] != top[v]) {",
			"      if (dep[top[u]] > dep[top[v]]) {",
			"        u = par[top[u]];",
			"      } else {",
			"        v = par[top[v]];",
			"      }",
			"    }",
			"    return dep[u] < dep[v] ? u : v;",
			"  }",
			"  ",
			"  int dist(int u, int v) {",
			"    return dep[u] + dep[v] - 2 * dep[lca(u, v)];",
			"  }",
			"  ",
			"  int jump(int u, int k) {",
			"    if (dep[u] < k) {",
			"      return -1;",
			"    }",
			"    ",
			"    int d = dep[u] - k;",
			"    ",
			"    while (dep[top[u]] > d) {",
			"      u = par[top[u]];",
			"    }",
			"    ",
			"    return seq[in[u] - dep[u] + d];",
			"  }",
			"  ",
			"  bool isAncester(int u, int v) {",
			"    return in[u] <= in[v] && in[v] <= out[u];",
			"  }",
			"  ",
			"  int rootedParent(int u, int v) {",
			"    swap(u, v);",
			"    if (u == v) {",
			"      return u;",
			"    }",
			"    if (!isAncester(u, v)) {",
			"      return par[u];",
			"    }",
			"    auto it = upper_bound(adj[u].begin(), adj[u].end(), v, [&](int x, int y) {",
			"      return in[x] < in[y];",
			"    }) - 1;",
			"    return *it;",
			"  }",
			"  ",
			"  int rootedSize(int u, int v) {",
			"    if (u == v) {",
			"      return n;",
			"    }",
			"    if (!isAncester(v, u)) {",
			"      return siz[v];",
			"    }",
			"    return n - siz[rootedParent(u, v)];",
			"  }",
			"  ",
			"  int rootedLca(int a, int b, int c) {",
			"    return lca(a, b) ^ lca(b, c) ^ lca(c, a);",
			"  }",
			"};"
		],
		"description": "Heavy Light Decomposition"
	},
	"Running Median": {
		"prefix": "runningmedian",
		"body": [
			"struct Median{",
			"  multiset<int> l,r;",
			"  // size of l is either equal to r or one more than r",
			"  ",
			"  void balance(){",
			"    if(l.size() < r.size()){",
			"      int x = *r.begin();",
			"      l.insert(x);",
			"      r.erase(r.find(x));",
			"    }",
			"    if(l.size() > r.size()+1){",
			"      int x = *l.rbegin();",
			"      r.insert(x);",
			"      l.erase(l.find(x));",
			"    }",
			"  }",
			"  void insert(int x){",
			"    if(l.empty()) l.insert(x);",
			"    else if(x <= *l.rbegin()) l.insert(x);",
			"    else r.insert(x);",
			"    balance();",
			"  }",
			"  void remove(int x){",
			"    if(r.find(x) != r.end()) r.erase(r.find(x));",
			"    else l.erase(l.find(x));",
			"    balance();",
			"  }",
			"  int getMedian(){",
			"    int n = l.size() + r.size();",
			"    if(n == 0) return -1;",
			"    return *l.rbegin();",
			"  }",
			"};"
		],
		"description": "Running Median"
	},
	"Running Mode": {
		"prefix": "runningmode",
		"body": [
			"struct Mode{",
			"  map<int,int> f;",
			"  set<pair<int,int>> st;",
			"  void insert(int x){",
			"    if(st.find({f[x],x}) != st.end()){",
			"      st.erase({f[x],x});",
			"    }",
			"    f[x]++;",
			"    st.insert({f[x],x});",
			"  }",
			"  void remove(int x){",
			"    if(st.find({f[x],x}) != st.end()){",
			"      st.erase({f[x],x});",
			"    }",
			"    f[x]--;",
			"    if(f[x]>0) st.insert({f[x],x});",
			"  }",
			"  int getMode(){",
			"    if(st.empty()) return -1;",
			"    return st.rbegin()->second;",
			"  }",
			"  int getMaxFreq(){",
			"    if(st.empty()) return 0;",
			"    return st.rbegin()->first;",
			"  }",
			"};"
		],
		"description": "Running Mode"
	},
	"Longest Prefix Suffix": {
		"prefix": "lps",
		"body": [
			"template <typename T>",
			"vector<int> lps(const T &s, int n = 1){",
			"  n = (int)s.size();",
			"  vector<int> lps(n);",
			"  int j = 0;",
			"  for(int i = 1;i < n;i++){",
			"    while(j > 0 && s[i] != s[j]) j = lps[j-1];",
			"    if(s[i] == s[j]) j++;",
			"    lps[i] = j;",
			"  }",
			"  return lps;",
			"}"
		],
		"description": "Longest Prefix Suffix"
	},
	"Knuth Morris Pratt": {
		"prefix": "kmp",
		"body": [
			"template <typename T>",
			"vector<int> kmp(const T &s, const T &p){",
			"  int n = (int)s.size(), m = (int)p.size();",
			"  vector<int> lps = lps(p);",
			"  vector<int> ans;",
			"  int j = 0;",
			"  for(int i = 0;i < n;i++){",
			"    while(j > 0 && s[i] != p[j]) j = lps[j-1];",
			"    if(s[i] == p[j]) j++;",
			"    if(j == m){",
			"      ans.push_back(i-j+1);",
			"      j = lps[j-1];",
			"    }",
			"  }",
			"  return ans;",
			"}"
		],
		"description": "Knuth Morris Pratt"
	},
	"Z Function": {
		"prefix": "zfunction",
		"body": [
			"template <typename T>",
			"vector<int> z(const T &s, int n = 1){",
			"  n = (int)s.size();",
			"  vector<int> z(n);",
			"  int L = 0, R = 0;",
			"  for(int i = 1;i < n;i++){",
			"    if(i < R) z[i] = min(R-i,z[i-L]);",
			"    while(i + z[i] < n && s[z[i]] == s[i+z[i]]) z[i]++;",
			"    if(i + z[i] > R){",
			"      L = i;",
			"      R = i+z[i];",
			"    }",
			"  }",
			"  return z;",
			"}"
		],
		"description": "Z Function"
	},
	"String hashing": {
		"prefix": "hash61",
		"body": [
			"struct Hash61 {",
			"  static const uint64_t md = (1LL << 61) - 1;",
			"  static uint64_t base;",
			"  static vector<uint64_t> pw;",
			" ",
			"  uint64_t addmod(uint64_t a, uint64_t b) const {",
			"    a += b;",
			"    if (a >= md) a -= md;",
			"    return a;",
			"  }",
			" ",
			"  uint64_t submod(uint64_t a, uint64_t b) const {",
			"    a += md - b;",
			"    if (a >= md) a -= md;",
			"    return a;",
			"  }",
			" ",
			"  uint64_t mulmod(uint64_t a, uint64_t b) const {",
			"    uint64_t l1 = (uint32_t) a, h1 = a >> 32, l2 = (uint32_t) b, h2 = b >> 32;",
			"    uint64_t l = l1 * l2, m = l1 * h2 + l2 * h1, h = h1 * h2;",
			"    uint64_t ret = (l & md) + (l >> 61) + (h << 3) + (m >> 29) + (m << 35 >> 3) + 1;",
			"    ret = (ret & md) + (ret >> 61);",
			"    ret = (ret & md) + (ret >> 61);",
			"    return ret - 1;",
			"  }",
			" ",
			"  void ensure_pw(int sz) {",
			"    int cur = (int) pw.size();",
			"    if (cur < sz) {",
			"      pw.resize(sz);",
			"      for (int i = cur; i < sz; i++) {",
			"        pw[i] = mulmod(pw[i - 1], base);",
			"      }",
			"    }",
			"  }",
			" ",
			"  vector<uint64_t> pref, suff;",
			"  int n;",
			" ",
			"  template<typename T>",
			"  Hash61(const T& s) {",
			"    n = (int) s.size();",
			"    ensure_pw(n + 1);",
			"    pref.resize(n + 1);",
			"    pref[0] = 1;",
			"    for (int i = 0; i < n; i++) {",
			"      pref[i + 1] = addmod(mulmod(pref[i], base), s[i]);",
			"    }",
			"  }",
			" ",
			"  inline uint64_t operator()(const int from, const int to) const {",
			"    assert(0 <= from && from <= to && to <= n - 1);",
			"    return submod(pref[to + 1], mulmod(pref[from], pw[to - from + 1]));",
			"  }",
			"};",
			"",
			"mt19937_64 rng61(chrono::steady_clock::now().time_since_epoch().count());",
			"uint64_t Hash61::base = (md >> 2) + rng61() % (md >> 1);",
			"vector<uint64_t> Hash61::pw = vector<uint64_t>(1, 1);"
		],
		"description": "String hashing"
	}
}